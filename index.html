<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bullet Hell — Robotic v3+ (Bombs)</title>
<style>
  :root{
    --bg:#05060a; --panel:#0b0d10; --muted:#98a2ad; --steel:#9aa6b2; --accent:#4fe0ff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#03040a,#071019);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6}
  canvas{display:block;width:100vw;height:100vh;background:transparent}
  #ui{position:absolute;inset:0;pointer-events:none}
  .center{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:auto}
  .panel{background:rgba(255,255,255,0.02);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 12px 40px rgba(0,0,0,0.6);width:860px;max-width:94%}
  h1{margin:0;font-size:30px}
  .muted{color:var(--muted);font-size:13px}
  .row{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}
  button.btn{pointer-events:auto;border:0;padding:10px 16px;border-radius:10px;background:linear-gradient(180deg,#0b0f13,#0f1418);color:var(--accent);font-weight:700;cursor:pointer}
  button.btn.alt{background:linear-gradient(180deg,#14040a,#2b0712);color:#ff6b6b}
  #hud{position:absolute;left:12px;top:12px;pointer-events:none;display:flex;gap:10px}
  .chip{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);font-weight:800}
  #scoreBig{position:absolute;left:50%;top:12px;transform:translateX(-50%);pointer-events:none;font-weight:900;font-size:20px;background:rgba(255,255,255,0.02);padding:8px 12px;border-radius:12px}
  input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#fff}
  #controls{position:absolute;bottom:12px;left:12px;pointer-events:none;background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;color:var(--muted)}
  .leaderboard{ text-align:left; color:var(--muted); margin-top:8px; }
  @media (max-width:720px){ .panel{padding:12px} h1{font-size:22px} }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div id="hud">
    <div class="chip" id="timeChip">Time: 0.00s</div>
    <div class="chip" id="multChip">Lives: 3</div>
  </div>

  <div id="scoreBig">BULLET HELL • Score: <span id="scoreVal">0</span></div>

  <!-- Menu -->
  <div id="menu" class="center">
    <div class="panel">
      <h1>BULLET HELL</h1>
      <p class="muted">Robotic grey style. Faster movement. Slower score. You have 3 lives. New bombs, saws, lasers and heavy bullet patterns. Telegraphed explosions so you can dodge.</p>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px">
        <button id="startBtn" class="btn">Start (Space)</button>
        <button id="tutorialBtn" class="btn">How to Play</button>
        <button id="resetSave" class="btn alt">Reset Leaderboard</button>
      </div>
      <div class="row" style="margin-top:14px;justify-content:space-between;align-items:center">
        <div style="text-align:center">
          <div class="muted">High Score</div>
          <div style="font-weight:900;font-size:18px" id="highScore">0</div>
        </div>
        <div style="width:18px"></div>
        <div style="text-align:left">
          <div class="muted">Local Leaderboard (Top 5)</div>
          <div id="leaderboard" class="leaderboard">No entries yet</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tutorial -->
  <div id="tutorial" class="center" style="display:none;pointer-events:auto">
    <div class="panel">
      <h1>How to Play</h1>
      <p class="muted">Move with arrow keys or WASD. Avoid bullets, moving saws, telegraphed lasers and bombs. Bombs appear with a blinking warning and explode with a radius you must dodge. You have 3 lives — each hit costs a life and grants brief invulnerability.</p>
      <div class="row"><button id="tBack" class="btn">Back</button></div>
    </div>
  </div>

  <!-- Pause -->
  <div id="pause" class="center" style="display:none;pointer-events:auto">
    <div class="panel">
      <h1>Paused</h1>
      <p class="muted">Press P to resume, R to restart.</p>
      <div class="row"><button id="resumeBtn" class="btn">Resume (P)</button><button id="rBtn" class="btn alt">Restart (R)</button></div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOver" class="center" style="display:none;pointer-events:auto">
    <div class="panel">
      <h1>Run Over</h1>
      <p class="muted">You lasted <span id="finalTime">0.00</span>s — Score: <strong id="finalScore">0</strong></p>
      <div style="display:flex;gap:8px;justify-content:center;align-items:center">
        <input id="playerName" type="text" placeholder="Name (max 12)" maxlength="12" />
        <button id="saveBtn" class="btn">Save Score</button>
      </div>
      <div class="row" style="margin-top:12px"><button id="tryBtn" class="btn">Try Again</button><button id="menuBtn" class="btn alt">Main Menu</button></div>
      <div style="margin-top:12px">
        <div class="muted">Leaderboard</div>
        <div id="gameOverLB" class="leaderboard"></div>
      </div>
    </div>
  </div>

  <div id="controls">Move: Arrows/WASD • P = Pause • R = Restart</div>
</div>

<script>
/*
Bullet Hell (v3+) — bombs added, player slightly faster, renamed UI.
- Bombs: telegraphed warning blink then explode (AoE). Dodge the blast!
- Keep lasers, saws, bullets, 3 lives, invulnerability, leaderboard.
*/

// Canvas & utils
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=> { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.sqrt(dx*dx+dy*dy); }
function circleRectColl(cx,cy,r,rx,ry,rw,rh){ const nx = Math.max(rx, Math.min(cx, rx+rw)); const ny = Math.max(ry, Math.min(cy, ry+rh)); const dx = cx - nx, dy = cy - ny; return dx*dx + dy*dy <= r*r; }
function rectIntersect(ax,ay,aw,ah,bx,by,bw,bh){ return !(ax + aw < bx || ax > bx + bw || ay + ah < by || ay > by + bh); }

// DOM refs & leaderboard keys
const LB_KEY = 'bullethell_lb_v1';
const SAVE_KEY = 'bullethell_save_v1';

const menu = document.getElementById('menu'), tutorial = document.getElementById('tutorial'), pausePanel = document.getElementById('pause'), gameOverPanel = document.getElementById('gameOver');
const startBtn = document.getElementById('startBtn'), tutorialBtn = document.getElementById('tutorialBtn'), tBack = document.getElementById('tBack');
const resumeBtn = document.getElementById('resumeBtn'), rBtn = document.getElementById('rBtn');
const tryBtn = document.getElementById('tryBtn'), menuBtn = document.getElementById('menuBtn');
const saveBtn = document.getElementById('saveBtn'), playerNameInput = document.getElementById('playerName');
const timeChip = document.getElementById('timeChip'), multChip = document.getElementById('multChip');
const scoreVal = document.getElementById('scoreVal'), highScoreEl = document.getElementById('highScore');
const leaderboardEl = document.getElementById('leaderboard'), gameOverLB = document.getElementById('gameOverLB');
const resetSaveBtn = document.getElementById('resetSave'), finalTimeEl = document.getElementById('finalTime');

startBtn.onclick = startGame;
tutorialBtn.onclick = ()=>{ menu.style.display='none'; tutorial.style.display='flex'; }
tBack.onclick = ()=>{ tutorial.style.display='none'; menu.style.display='flex'; }
resumeBtn.onclick = togglePause;
rBtn.onclick = restart;
tryBtn.onclick = ()=>{ restart(); gameOverPanel.style.display='none'; }
menuBtn.onclick = ()=>{ gameOverPanel.style.display='none'; menu.style.display='flex'; }
saveBtn.onclick = ()=>{ const name = playerNameInput.value.trim() || '---'; const list = addToLeaderboard(name, score); gameOverLB.innerHTML = formatLeaderboard(list); updateMenuLB(); saveBtn.disabled = true; }
resetSaveBtn.onclick = ()=>{ if (confirm('Clear leaderboard & high score?')) { localStorage.removeItem(LB_KEY); localStorage.removeItem(SAVE_KEY); loadSave(); updateMenuLB(); alert('Cleared'); } }

document.addEventListener('keydown', (e)=> {
  if ((e.key === ' ' || e.code === 'Space') && !running) startGame();
  if (e.key === 'p') togglePause();
  if (e.key === 'r') restart();
});

// leaderboard persistence
function loadLB(){ try{const s=localStorage.getItem(LB_KEY); return s?JSON.parse(s):[];}catch{return [];} }
function saveLB(list){ localStorage.setItem(LB_KEY, JSON.stringify(list)); }
function addToLeaderboard(name, scr){
  const lb = loadLB();
  lb.push({ name: name.slice(0,12), score: Math.round(scr), date: new Date().toISOString() });
  lb.sort((a,b)=> b.score - a.score);
  const top = lb.slice(0,5);
  saveLB(top);
  return top;
}
function formatLeaderboard(list){
  if (!list || list.length===0) return '<div style="opacity:0.8">No entries yet</div>';
  let html = '<ol style="padding-left:16px;margin:6px 0">';
  list.forEach(e => html += `<li style="margin-bottom:6px"><strong style="color:#fff">${e.name}</strong> — ${e.score}</li>`);
  html += '</ol>';
  return html;
}
function loadSave(){ try{const s=localStorage.getItem(SAVE_KEY); return s?JSON.parse(s):{high:0}; }catch{return {high:0}} }
function saveSave(obj){ localStorage.setItem(SAVE_KEY, JSON.stringify(obj)); }
let saveState = loadSave();
function updateMenuLB(){ leaderboardEl.innerHTML = formatLeaderboard(loadLB()); highScoreEl.textContent = Math.round(saveState.high || 0); }
updateMenuLB();

// game state
let running=false, paused=false, last = performance.now();
let score = 0, timeAlive = 0, difficulty = 1.0;
let lives = 3;
let invulTimer = 0; // ms invulnerability after hit
// player: slightly faster than v3 (just a bit faster)
let player = { x: W/2, y: H*0.75, w: 18, h: 22, vx:0, vy:0, accel:0.46, friction:0.80, vmax:15.6 }; // small bump
let keys = {};
let bullets = [], lasers = [], saws = [], bombs = [], spawners = [], particles = [];

window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

// tuning
const TUNE = {
  spawnIntervalBase: 1200,
  spawnRandomChance: 0.0022,
  difficultyRamp: 0.000045,
  scorePerMs: 0.0022,
  sawSpawnChanceWhenSpawner: 0.14,
  sawDensityLimit: 4,
  bombSpawnChanceWhenSpawner: 0.08, // chance to spawn bomb instead of saw/bullets
  bombWarn: 900, // ms warning before explosion
  bombFuseMin: 1200, // minimum ms between warn start and explosion if using different timing
  bombRadiusMin: 60,
  bombRadiusMax: 110
};

// spawn helpers
function spawnBullet(x,y,vx,vy,r=6,color='#9aa6b2', kind='normal', life=9000){
  bullets.push({ x,y,vx,vy,r,color,kind,life });
}
function spawnHoming(x,y,speed=2.2,r=6){
  const angle = Math.atan2(player.y - y, player.x - x);
  spawnBullet(x,y,Math.cos(angle)*speed,Math.sin(angle)*speed,r,'#9aa6b2','homing',6000);
}
function spawnLaser(x,y,w,h,warn=700,fire=450){
  lasers.push({ x,y,w,h,warn,fire,phase:'warn',timer:0, color:'#4fe0ff' });
}
function spawnSaw(x,y,range=80,speed=1.2,size=36){
  if (saws.length >= TUNE.sawDensityLimit) return;
  saws.push({ x0:x, y:y, range:range, speed:speed, dir: (Math.random()<0.5?1:-1), off:0, size:size });
}
function spawnBomb(x,y, warn = TUNE.bombWarn, fuse = TUNE.bombFuseMin, radius = null){
  // bomb appears at (x,y) and blinks for warn ms then explodes with radius
  bombs.push({ x:x, y:y, vy:0, warnTimer: warn, fuse: fuse, timer:0, state:'warn', radius: radius || rand(TUNE.bombRadiusMin, TUNE.bombRadiusMax), exploded:false, flashPhase:0 });
}
function spawnParticles(x,y,color,count=10){
  for (let i=0;i<count;i++) particles.push({ x, y, vx:rand(-2.2,2.2), vy:rand(-3.2,-0.6), life:300 + Math.random()*240, size:2 + Math.random()*3, color});
}
function addSpawner(type,x,y,opts){
  spawners.push({ type, x, y, opts: opts||{}, timer:0, interval: TUNE.spawnIntervalBase + rand(0,700) });
}

// spawners: sometimes spawn bombs
function updateSpawners(dt){
  for (let i=spawners.length-1;i>=0;i--){
    const s = spawners[i];
    s.timer += dt;
    const effInterval = Math.max(240, s.interval * (1 - (difficulty-1)*0.06));
    if (s.timer >= effInterval){
      s.timer = 0;
      // bomb branch
      if (Math.random() < TUNE.bombSpawnChanceWhenSpawner){
        // spawn bomb somewhere in upper half, telegraphed
        const bx = clamp(s.x + rand(-60,60), 60, W - 60);
        const by = rand(60, H*0.35);
        spawnBomb(bx, by, TUNE.bombWarn, TUNE.bombFuseMin + rand(0,400), rand(TUNE.bombRadiusMin, TUNE.bombRadiusMax));
      } else if (Math.random() < TUNE.sawSpawnChanceWhenSpawner) {
        const sy = Math.max(120, Math.min(H-160, s.y + rand(-30, 40)));
        spawnSaw(s.x + rand(-60,60), sy, 50 + Math.random()*90, 0.9 + Math.random()*0.8, 32 + Math.random()*8);
      } else {
        // bullet patterns
        if (s.type === 'spiral'){
          const count = Math.min(30, 10 + Math.floor(difficulty*4));
          let base = s.opts.angle || 0;
          for (let k=0;k<count;k++){
            const a = base + (k * (Math.PI*2 / count)) + rand(-0.03, 0.03);
            const speed = 1.0 + difficulty*0.26 + Math.random()*0.45;
            spawnBullet(s.x, s.y, Math.cos(a)*speed, Math.sin(a)*speed, 4 + Math.random()*2, '#9aa6b2','normal',7000);
          }
          s.opts.angle = base + ((Math.random()<0.5?1:-1) * 0.14);
        } else if (s.type === 'radial'){
          const count = Math.min(28, 6 + Math.floor(5 * difficulty));
          for (let k=0;k<count;k++){
            const a = (k/count)*Math.PI*2 + rand(-0.02, 0.02);
            const speed = 1.4 + difficulty*0.36;
            spawnBullet(s.x, s.y, Math.cos(a)*speed, Math.sin(a)*speed, 5, '#8f99a0','normal',7000);
          }
        } else if (s.type === 'shower'){
          const count = 6 + Math.floor(difficulty*3);
          for (let k=0;k<count;k++){
            const sx = rand(40, W-40);
            const sp = 1.6 + difficulty*0.4 + Math.random()*0.4;
            spawnBullet(sx, -20, 0, sp, 6, '#aab2b6','normal',8000);
          }
        } else if (s.type === 'homing'){
          const count = 1 + Math.floor(difficulty*0.8);
          for (let k=0;k<count;k++) spawnHoming(s.x + rand(-8,8), s.y + rand(-8,8), 2.0 + difficulty*0.18 + Math.random()*0.2);
        } else if (s.type === 'wall'){
          const segments = 6 + Math.floor(difficulty*3);
          for (let k=0;k<segments;k++){
            const sx = 40 + k * ((W-80)/segments) + rand(-6,6);
            spawnBullet(sx, s.y, 0, 1.6 + difficulty*0.2, 6, '#b7bcc0','normal',7000);
          }
        }
        // small chance to spawn a vertical laser
        if (Math.random() < clamp(0.04 + difficulty*0.008, 0, 0.12)) {
          const lx = rand(80, W-80);
          spawnLaser(lx - 6, 40, 12, H-80, 700, 450);
        }
      }
    }
    if (Math.random() < 0.0003 * dt) spawners.splice(i,1);
  }

  // occasional new spawner
  if (Math.random() < (TUNE.spawnRandomChance * (difficulty/1.2))) {
    const r = Math.random();
    if (r < 0.35) addSpawner('spiral', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.63) addSpawner('radial', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.82) addSpawner('shower', 0, -10, {});
    else addSpawner('homing', rand(80, W-80), rand(20, H*0.4), {});
  }
}

// bullets/lasers/saws/bombs update
function updateBullets(dt){
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if (b.kind === 'homing'){
      const ang = Math.atan2(player.y - b.y, player.x - b.x);
      const sp = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
      const cur = Math.atan2(b.vy, b.vx);
      const na = cur + ((ang - cur) * 0.035);
      b.vx = Math.cos(na)*sp; b.vy = Math.sin(na)*sp;
    }
    b.x += b.vx * (dt/16.67);
    b.y += b.vy * (dt/16.67);
    b.life -= dt;
    if (b.life <= 0 || b.x < -60 || b.x > W+60 || b.y < -120 || b.y > H+120) bullets.splice(i,1);
  }
  for (let i=lasers.length-1;i>=0;i--){
    const L = lasers[i];
    L.timer += dt;
    if (L.phase === 'warn' && L.timer >= L.warn){ L.phase = 'fire'; L.timer = 0; spawnParticles(L.x + L.w/2, 60, '#4fe0ff', 14); }
    else if (L.phase === 'fire' && L.timer >= L.fire){ L.phase = 'cool'; L.timer = 0; }
    else if (L.phase === 'cool' && L.timer >= 420){ lasers.splice(i,1); }
  }
  for (let i=saws.length-1;i>=0;i--){
    const s = saws[i];
    s.off += s.dir * s.speed * (dt/16.67);
    if (Math.abs(s.off) > s.range) s.dir *= -1;
    const worldX = s.x0 + s.off;
    if (worldX < -120 || worldX > W + 120) saws.splice(i,1);
  }
  // bombs timing & explosions
  for (let i=bombs.length-1;i>=0;i--){
    const b = bombs[i];
    b.timer += dt;
    // blink phase while warning
    if (b.state === 'warn'){
      b.flashPhase += dt;
      if (b.timer >= b.warnTimer){
        b.state = 'fuse';
        b.timer = 0;
      }
    } else if (b.state === 'fuse'){
      b.timer += 0; // fuse progression uses timer
      if (b.timer >= b.fuse){
        // explode
        b.exploded = true;
        b.state = 'explode';
        b.explodeTimer = 0;
        spawnParticles(b.x, b.y, '#ffb97a', 30);
      }
    } else if (b.state === 'explode'){
      b.explodeTimer += dt;
      // explosion lasts ~420ms, during which AoE applies
      if (b.explodeTimer >= 420) { bombs.splice(i,1); continue; }
    }
  }
}

function updateParticles(dt){
  for (let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.life -= dt;
    p.x += p.vx * (dt/16.67); p.y += p.vy * (dt/16.67);
    p.vy += 0.04 * (dt/16.67);
    if (p.life <= 0) particles.splice(i,1);
  }
}

// player movement (just a bit faster)
function updatePlayer(dt){
  let ax = 0, ay = 0;
  if (keys['arrowleft'] || keys['a']) ax -= 1;
  if (keys['arrowright'] || keys['d']) ax += 1;
  if (keys['arrowup'] || keys['w']) ay -= 1;
  if (keys['arrowdown'] || keys['s']) ay += 1;
  player.vx += ax * player.accel * (dt/16.67);
  player.vy += ay * player.accel * (dt/16.67);
  const sp = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
  if (sp > player.vmax){ player.vx = player.vx/sp * player.vmax; player.vy = player.vy/sp * player.vmax; }
  player.vx *= Math.pow(player.friction, dt/16.67);
  player.vy *= Math.pow(player.friction, dt/16.67);
  player.x += player.vx * (dt/16.67);
  player.y += player.vy * (dt/16.67);
  player.x = clamp(player.x, 16, W - 16 - player.w);
  player.y = clamp(player.y, 16, H - 16 - player.h);
}

// collisions & lives
function handleHit(){
  lives = Math.max(0, lives - 1);
  invulTimer = 1600;
  const safeRadius = 90;
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if (dist(b.x, b.y, player.x + player.w/2, player.y + player.h/2) < safeRadius) bullets.splice(i,1);
  }
  // destroy nearby bombs that haven't exploded? no — keep potential hazards but clear very close ones
  for (let i=bombs.length-1;i>=0;i--){
    const bb = bombs[i];
    if (bb.state !== 'explode' && dist(bb.x, bb.y, player.x + player.w/2, player.y + player.h/2) < 40) bombs.splice(i,1);
  }
  spawnParticles(player.x + player.w/2, player.y + player.h/2, '#ffe9d6', 28);
  player.x = W*0.5 + rand(-30,30);
  player.y = H*0.68 + rand(-18,18);
  player.vx = player.vy = 0;
  if (lives <= 0) endRun();
}

function checkCollisions(dt){
  if (invulTimer > 0) return;
  // bullets
  for (let i=0;i<bullets.length;i++){
    const b = bullets[i];
    if (circleRectColl(b.x, b.y, b.r + 1, player.x, player.y, player.w, player.h)){
      bullets.splice(i,1);
      handleHit();
      return;
    }
  }
  // lasers
  for (let i=0;i<lasers.length;i++){
    const L = lasers[i];
    if (L.phase === 'fire'){
      if (rectIntersect(player.x, player.y, player.w, player.h, L.x, L.y, L.w, L.h)){
        handleHit(); return;
      }
    }
  }
  // saws
  for (let i=0;i<saws.length;i++){
    const s = saws[i];
    const sx = s.x0 + s.off, sy = s.y;
    const r = s.size*0.45;
    if (circleRectColl(sx + s.size/2, sy + s.size/2, r + 1, player.x, player.y, player.w, player.h)){
      handleHit(); return;
    }
  }
  // bombs explosions
  for (let i=0;i<bombs.length;i++){
    const b = bombs[i];
    if (b.state === 'explode'){
      const ex = b.x, ey = b.y, r = b.radius;
      const cx = player.x + player.w/2, cy = player.y + player.h/2;
      if (dist(ex,ey,cx,cy) <= r){
        handleHit(); return;
      }
    }
  }
}

// difficulty & scoring
function updateDifficultyAndScore(dt){
  timeAlive += dt;
  difficulty += TUNE.difficultyRamp * dt;
  score += dt * TUNE.scorePerMs * difficulty;
}

// main loop
function loop(now){
  if (!running || paused) return;
  const dt = Math.min(40, now - last);
  last = now;

  if (Math.random() < (TUNE.spawnRandomChance * (difficulty/1.08))) {
    const r = Math.random();
    if (r < 0.35) addSpawner('spiral', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.63) addSpawner('radial', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.82) addSpawner('shower', 0, -10, {});
    else addSpawner('homing', rand(80, W-80), rand(20, H*0.4), {});
  }

  updateSpawners(dt);
  updateBullets(dt);
  updateParticles(dt);
  updatePlayer(dt);

  if (invulTimer > 0){ invulTimer -= dt; if (invulTimer < 0) invulTimer = 0; }
  checkCollisions(dt);
  updateDifficultyAndScore(dt);

  // UI
  timeChip.textContent = 'Time: ' + (timeAlive/1000).toFixed(2) + 's';
  multChip.textContent = 'Lives: ' + '♥'.repeat(lives);
  scoreVal.textContent = Math.round(score);

  draw();
  requestAnimationFrame(loop);
}

// draw
function draw(){
  ctx.clearRect(0,0,W,H);
  // background
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#05060a'); g.addColorStop(1,'#08101a');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // faint grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  for (let x=0;x<W;x+=80){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y=0;y<H;y+=80){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // saws
  for (const s of saws){
    const sx = s.x0 + s.off, sy = s.y, size = s.size;
    ctx.save(); ctx.translate(sx + size/2, sy + size/2);
    const rot = performance.now() / 100 * (s.dir > 0 ? 1 : -1);
    ctx.rotate(rot);
    ctx.fillStyle = '#bfc7cc'; circle(0,0, size*0.44);
    ctx.fillStyle = '#ff6b6b';
    for (let t=0;t<10;t++){
      const ang = t * (Math.PI*2/10);
      ctx.beginPath(); ctx.moveTo(Math.cos(ang)*(size*0.45), Math.sin(ang)*(size*0.45)); ctx.lineTo(Math.cos(ang+0.12)*(size*0.75), Math.sin(ang+0.12)*(size*0.75)); ctx.lineTo(Math.cos(ang-0.12)*(size*0.75), Math.sin(ang-0.12)*(size*0.75)); ctx.closePath(); ctx.fill();
    }
    ctx.restore();
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(sx + 2, sy + size - 4, size - 4, 6);
  }

  // bullets
  for (const b of bullets){
    ctx.beginPath(); ctx.fillStyle = b.color; ctx.ellipse(b.x, b.y, b.r, b.r, 0, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(79,224,255,0.05)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.ellipse(b.x, b.y, b.r*1.6, b.r*1.6, 0,0,Math.PI*2); ctx.stroke();
  }

  // lasers
  for (const L of lasers){
    if (L.phase === 'warn'){
      ctx.fillStyle = 'rgba(79,224,255,0.06)'; ctx.fillRect(L.x, L.y, L.w, L.h);
      const a = 0.12 + 0.06 * Math.sin(performance.now()/120);
      ctx.strokeStyle = `rgba(79,224,255,${a})`; ctx.lineWidth = 2; ctx.strokeRect(L.x+1, L.y+1, L.w-2, L.h-2);
    } else if (L.phase === 'fire'){
      ctx.fillStyle = 'rgba(79,224,255,0.92)'; ctx.fillRect(L.x, L.y, L.w, L.h);
      ctx.fillStyle = 'rgba(79,224,255,0.14)'; ctx.fillRect(L.x - 12, L.y, L.w + 24, L.h);
    }
  }

  // bombs: draw warning, fuse, explosion
  for (const b of bombs){
    if (b.state === 'warn'){
      // blinking indicator (circle) with small pulsing
      const alpha = 0.18 + 0.12 * Math.sin(performance.now()/120);
      ctx.fillStyle = `rgba(255,187,110,${alpha})`;
      ctx.beginPath(); ctx.ellipse(b.x, b.y, 14 + Math.sin(b.flashPhase/80)*4, 14 + Math.sin(b.flashPhase/80)*4, 0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2b2b2b'; circle(b.x, b.y, 9);
      // small fuse or tick mark
      ctx.strokeStyle = 'rgba(0,0,0,0.45)'; ctx.beginPath(); ctx.moveTo(b.x-4, b.y-6); ctx.lineTo(b.x+4, b.y-6); ctx.stroke();
    } else if (b.state === 'fuse'){
      // small darker bomb with small fuse glow
      ctx.fillStyle = '#2b2b2b'; circle(b.x, b.y, 10);
      const tfrac = b.timer / b.fuse;
      ctx.fillStyle = `rgba(255,150,60,${0.8 - tfrac*0.5})`; circle(b.x, b.y - 12, 3 + 6*tfrac);
    } else if (b.state === 'explode'){
      // explosion ring
      const progress = clamp(b.explodeTimer / 420, 0, 1);
      const r = b.radius * (0.6 + 0.9 * progress);
      ctx.fillStyle = `rgba(255,160,80,${0.28 - 0.25*progress})`; ctx.beginPath(); ctx.ellipse(b.x, b.y, r, r, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = `rgba(255,200,140,${0.9 - 0.9*progress})`; circle(b.x, b.y, Math.max(6, 20*(1-progress)));
    }
  }

  // particles
  for (const p of particles){
    ctx.fillStyle = p.color; ctx.globalAlpha = clamp(p.life/500, 0, 1); ctx.beginPath(); ctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
  }

  // player (robotic)
  const px = player.x, py = player.y, pw = player.w, ph = player.h;
  const invulAlpha = invulTimer > 0 ? (Math.sin(performance.now()/80) > 0 ? 0.28 : 1.0) : 1.0;
  ctx.globalAlpha = invulAlpha;
  ctx.fillStyle = '#0b1014'; roundRect(px - 3, py - 3, pw + 6, ph + 6, 6);
  ctx.fillStyle = '#9aa6b2'; roundRect(px, py, pw, ph, 6);
  ctx.strokeStyle = 'rgba(0,0,0,0.28)'; ctx.lineWidth = 1; ctx.strokeRect(px+2, py+6, pw-4, ph-12);
  ctx.fillStyle = '#0e2f33'; roundRect(px + pw*0.2, py + ph*0.25, pw*0.6, ph*0.22, 4);
  ctx.fillStyle = '#4fe0ff'; ctx.fillRect(px + pw*0.22, py + ph*0.28, pw*0.58, ph*0.12);
  ctx.fillStyle = '#0b1014'; ctx.fillRect(px + pw*0.5 - 2, py - 8, 4, 8);
  ctx.fillStyle = '#4fe0ff'; circle(px + pw*0.5, py - 10, 3);
  ctx.globalAlpha = 1;
}

function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }
function circle(x,y,r){ ctx.beginPath(); ctx.ellipse(x,y,r,r,0,0,Math.PI*2); ctx.fill(); }

// init/reset/start/end functions
function resetWorld(){
  bullets = []; lasers = []; saws = []; bombs = []; spawners = []; particles = [];
  score = 0; timeAlive = 0; difficulty = 1.0;
  lives = 3; invulTimer = 0;
  player.x = W*0.5; player.y = H*0.72; player.vx = player.vy = 0;
  addSpawner('spiral', W*0.5, H*0.25, {angle:0});
  addSpawner('radial', W*0.28, H*0.2, {});
  addSpawner('shower', 0, -10, {});
}

function startGame(){
  resetWorld();
  running = true; paused = false;
  menu.style.display='none'; tutorial.style.display='none'; pausePanel.style.display='none'; gameOverPanel.style.display='none';
  last = performance.now();
  requestAnimationFrame(loop);
}

function restart(){
  resetWorld();
  running = true; paused = false;
  menu.style.display='none'; gameOverPanel.style.display='none';
  last = performance.now();
  requestAnimationFrame(loop);
}

function togglePause(){
  if (!running) return;
  paused = !paused;
  pausePanel.style.display = paused ? 'flex' : 'none';
  if (!paused){ last = performance.now(); requestAnimationFrame(loop); }
}

function endRun(){
  running = false;
  if (score > (saveState.high || 0)){ saveState.high = Math.round(score); saveSave(saveState); }
  document.getElementById('finalScore').textContent = Math.round(score);
  document.getElementById('finalTime').textContent = (timeAlive/1000).toFixed(2);
  gameOverLB.innerHTML = formatLeaderboard(loadLB());
  gameOverPanel.style.display = 'flex';
  saveBtn.disabled = false;
  updateMenuLB();
}

// main loop
function loop(now){
  if (!running || paused) return;
  const dt = Math.min(40, now - last);
  last = now;

  if (Math.random() < (TUNE.spawnRandomChance * (difficulty/1.08))) {
    const r = Math.random();
    if (r < 0.35) addSpawner('spiral', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.63) addSpawner('radial', rand(80, W-80), rand(60, H*0.45), {});
    else if (r < 0.82) addSpawner('shower', 0, -10, {});
    else addSpawner('homing', rand(80, W-80), rand(20, H*0.4), {});
  }

  updateSpawners(dt);
  updateBullets(dt);
  updateParticles(dt);
  updatePlayer(dt);

  if (invulTimer > 0){ invulTimer -= dt; if (invulTimer < 0) invulTimer = 0; }
  checkCollisions(dt);
  updateDifficultyAndScore(dt);

  timeChip.textContent = 'Time: ' + (timeAlive/1000).toFixed(2) + 's';
  multChip.textContent = 'Lives: ' + '♥'.repeat(lives);
  scoreVal.textContent = Math.round(score);

  draw();
  requestAnimationFrame(loop);
}

// initial setup & show menu
resetWorld();
updateMenuLB();
menu.style.display='flex'; tutorial.style.display='none'; pausePanel.style.display='none'; gameOverPanel.style.display='none';

</script>
</body>
</html>
